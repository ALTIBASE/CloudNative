<!DOCTYPE html>
<html>
    <head>
        <title>Technical Documents(한국어) : 자주 발생하는 오류 메세지</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Technical Documents(한국어)</a></span>
                            </li>
                                                    <li>
                                <span><a href="Home_7340036.html">Home</a></span>
                            </li>
                                                    <li>
                                <span><a href="11698385.html">Altibase Precompiler 가이드</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Technical Documents(한국어) : 자주 발생하는 오류 메세지
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
    
            Created by <span class='author'> Shin beum-su</span> on Mar 29, 2017
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1624409852962 {padding: 0px;}
div.rbtoc1624409852962 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1624409852962 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1624409852962'>
<ul class='toc-indentation'>
<li><a href='#id-자주발생하는오류메세지-Connectiondoesnotexist.(SQLCODE=–2)'>Connection does not exist. (SQLCODE=–2)</a></li>
<li><a href='#id-자주발생하는오류메세지-Stringdatarighttruncated.(SQLCODE=1)'>String data right truncated. (SQLCODE=1)</a></li>
<li><a href='#id-자주발생하는오류메세지-Invalidsizeofdatatobindtoahostvariable[ColumnID=&lt;A%d&gt;,DataSize=&lt;B%d&gt;,DeclaredSizeofHostVariable=&lt;C%d&gt;](SQLCODE=-201144or-266423)'>Invalid size of data to bind to a host variable [ Column ID = &lt;A%d&gt;, Data Size = &lt;B%d&gt; , Declared Size of Host Variable = &lt;C%d&gt; ] (SQLCODE=-201144 or -266423)</a></li>
<li><a href='#id-자주발생하는오류메세지-Calculationstackoverflow(SQLCODE=-135187or-659475)'>Calculation stack overflow (SQLCODE=-135187 or -659475)</a></li>
<li><a href='#id-자주발생하는오류메세지-ValueoverfloworNumericvalueoutofrange(SQLCODE=-135184or-659472or-331890)'>Value overflow or Numeric value out of range (SQLCODE=-135184 or -659472 or -331890)</a></li>
<li><a href='#id-자주발생하는오류메세지-Conversionnotapplicable(SQLCODE=-135180or-659468)'>Conversion not applicable (SQLCODE=-135180 or -659468)</a></li>
<li><a href='#id-자주발생하는오류메세지-Invalidlengthofthedatatype(SQLCODE=-135181or-659469)'>Invalid length of the data type (SQLCODE=-135181 or -659469)</a></li>
<li><a href='#id-자주발생하는오류메세지-Invalidliteral(SQLCODE=-135185or-659473)'>Invalid literal (SQLCODE=-135185 or -659473)</a></li>
<li><a href='#id-자주발생하는오류메세지-Invalidcharactervalueforcastspecification(SQLCODE=-331893)'>Invalid character value for cast specification (SQLCODE=-331893)</a></li>
<li><a href='#id-자주발생하는오류메세지-Invalidcursorstate.(SQLCODE=-331822)orFunctionsequenceerror(SQLCODE=-331796)'>Invalid cursor state. (SQLCODE=-331822) or Function sequence error (SQLCODE= -331796)</a></li>
<li><a href='#id-자주발생하는오류메세지-Thecursormustbeopenedforfetch(SQLCODE=-1)orThecursordoesnotexist(SQLCODE=-589857)'>The cursor must be opened for fetch (SQLCODE=-1) or The cursor does not exist (SQLCODE=-589857)</a></li>
<li><a href='#id-자주발생하는오류메세지-Notenoughinsertvalues(SQLCODE=-200787)'>Not enough insert values (SQLCODE=-200787)</a></li>
<li><a href='#id-자주발생하는오류메세지-Thetablespacedoesnothaveenoughfreespace(SQLCODE=-69685or-69923)'>The tablespace does not have enough free space (SQLCODE=-69685 or -69923)</a></li>
<li><a href='#id-자주발생하는오류메세지-Inputliteralisnotlongenoughfordateformat.(SQLCODE=-135218)'>Input literal is not long enough for date format. (SQLCODE=-135218)</a></li>
<li><a href='#id-자주발생하는오류메세지-Literalsintheinputdonotmatchformatstring.(SQLCODE=-135224)'>Literals in the input do not match format string. (SQLCODE=-135224)</a></li>
<li><a href='#id-자주발생하는오류메세지-Thetransactionisalreadyactive.(SQLCODE=-266311or-266312)'>The transaction is already active. (SQLCODE=-266311 or -266312)</a></li>
<li><a href='#id-자주발생하는오류메세지-Therowalreadyexistsinauniqueindex.(SQLCODE=-69720)'>The row already exists in a unique index. (SQLCODE=-69720)</a></li>
<li><a href='#id-자주발생하는오류메세지-Unabletoinsert(orupdate)NULLintoNOTNULLcolumn.(SQLCODE=-200790)'>Unable to insert (or update) NULL into NOT NULL column. (SQLCODE=- 200790)</a></li>
<li><a href='#id-자주발생하는오류메세지-Indicatorvariablerequiredbutnotsupplied.(SQLCODE=-331841or-594101or594103)'>Indicator variable required but not supplied. (SQLCODE=-331841 or -594101 or 594103)</a></li>
<li><a href='#id-자주발생하는오류메세지-Client&#39;squeryexceededintheexecutiontimelimitation.(SQLCODE=-4164)'>Client&#39;s query exceeded in the execution time limitation. (SQLCODE=-4164)</a></li>
<li><a href='#id-자주발생하는오류메세지-Communicationlinkfailure.(SQLCODE=-331843or-331855)'>Communication link failure. (SQLCODE=-331843 or -331855)</a></li>
</ul>
</div></p><hr /><p>SQLCODE 및 sqlca.sqlerrm.sqlerrmc를 통해 확인되는 자주 발생하는 에러들을 정리해서 설명한다.  SQLCODE는 동일한 sqlca.sqlerrm.sqlerrmc에 대해 2개가 존재할 수 있는데 이것은 ALTIBASE 내부 모듈 중 오류가 발생한 모듈의 위치에 따라 다를 수 있기 때문이며 에러의 내용은 동일하기 때문에 조치 방법도 동일하다.<strong style="line-height: 1.42857;">     </strong></p><h2 id="id-자주발생하는오류메세지-Connectiondoesnotexist.(SQLCODE=–2)">Connection does not exist. (SQLCODE=–2)</h2><p>질의 처리 수행 과정에서 사용해야 할 연결 객체가 없거나 사라진 경우이다. 제대로 연결이 처리되었는지 여부를 확인하고 쓰레드 프로그램의 경우 EXEC SQL AT 절에 연결 명이 제대로 표기되었는지 확인해야 한다. 경우에 따라서는 DBMS서버에서 연결이 단절된 경우가 있을 수 있다. (오류 메시지 중 Timeout관련 메시지를 확인)  </p><h2 id="id-자주발생하는오류메세지-Stringdatarighttruncated.(SQLCODE=1)">String data right truncated. (SQLCODE=1)</h2><p>DB로부터 변수에 값을 담는 과정에서 선언된 변수의 길이가 작은 경우 발생한다. DB변수의 길이를 (데이터 길이+1byte)만큼 크게 변경하도록 한다.</p><h2 id="id-자주발생하는오류메세지-Invalidsizeofdatatobindtoahostvariable[ColumnID=&lt;A%d&gt;,DataSize=&lt;B%d&gt;,DeclaredSizeofHostVariable=&lt;C%d&gt;](SQLCODE=-201144or-266423)">Invalid size of data to bind to a host variable [ Column ID = &lt;A%d&gt;, Data Size = &lt;B%d&gt; , Declared Size of Host Variable = &lt;C%d&gt; ] (SQLCODE=-201144 or -266423)</h2><p>칼럼의 (A+1)번째의 실제 데이터는 B의 크기를 갖는데 호스트 변수의 길이는 C의 크기를 갖기 때문에 데이터 값이 변수의 길이를 넘은 경우 발생한다. 변수의 길이를 데이터의 길이보다 크게 잡아야 한다. 간혹, 호스트 변수의 메모리가 프로그램의 이상으로 깨진 경우에도 이와 같은 오류가 발생하기 때문에 호스트 변수의 memset 또는 메모리가 깨진 경우가 없는지 확인해야 한다. 또는, 쓰레드 프로그램의 경우에서 다수의 SQL문을 하나의 커넥션을 통해 동시성 제어가 제대로 되지 못할 경우에도 발생할 수 있다</p><h2 id="id-자주발생하는오류메세지-Calculationstackoverflow(SQLCODE=-135187or-659475)"><span style="color: rgb(0,0,0);">Calculation stack overflow (SQLCODE=-135187 or -659475)</span></h2><p>내부에서 질의 처리 과정에서 사용되는 stack의 크기를 넘은 경우 발생한다. 이 경우 해당 질의를 수행하기 전에 다음과 같이 SQL문을 수행하도록 한다. 기본값은 1024이다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">EXEC SQL ALTER SESSION SET STACK SIZE = 4096;</pre>
</div></div><p> </p><h2 id="id-자주발생하는오류메세지-ValueoverfloworNumericvalueoutofrange(SQLCODE=-135184or-659472or-331890)"><span style="color: rgb(0,0,0);">Value overflow or Numeric value out of range (SQLCODE=-135184 or -659472 or -331890)</span></h2><p>호스트 변수에 사용된 데이터의 값이 실제 DB에 정의된 칼럼의 표현 범위보다 큰 값이 입력된 경우이다. 데이터 값을 확인하고 필요 시 칼럼을 변경하도록 해야 한다.</p><h2 id="id-자주발생하는오류메세지-Conversionnotapplicable(SQLCODE=-135180or-659468)"><span style="color: rgb(0,0,0);">Conversion not applicable (SQLCODE=-135180 or -659468)</span></h2><p>ALTIBASE에 사용되는 칼럼의 데이터 타입 또는 호스트 변수의 타입간의 변환이 지원되지 않는 유형으로 사용한 경우에 발생한다. </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">Table T1 (c1 char(10));   

Insert into t1 values (&#39;A&#39;) ;
 

(O) update t1 set c1 = case2(C1 = 1, 0, 1) ;

(X) update t1 set c1 =  decode (C1=1, 0, 1); // decode의 인자에 Boolean타입은 안됨</pre>
</div></div><p>이 외에도 CLOB/BLOB의 핸들링에 있어 변환되지 않는 데이터 타입을 갖는 호스트 변수가 사용될 경우도 에러가 발생할 수 있다.</p><h2 id="id-자주발생하는오류메세지-Invalidlengthofthedatatype(SQLCODE=-135181or-659469)">Invalid length of the data type (SQLCODE=-135181 or -659469)</h2><p>DB의 칼럼에 저장 가능한 길이보다 큰 데이터가 입력되는 경우 발생한다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">Table T1 (c1 char(10));

(X) Insert into t1 values (&#39;AAAAAAAAAAAAAAAAAAAAAAAAA&#39;);</pre>
</div></div><h2 id="id-자주발생하는오류메세지-Invalidliteral(SQLCODE=-135185or-659473)"><span style="color: rgb(0,0,0);">Invalid literal (SQLCODE=-135185 or -659473)</span></h2><p>칼럼 타입이 숫자형으로 선언된 상태에서 사용한 호스트 변수에 숫자로 변환할 수 없는 문자열 있는 경우 발생한다.  또는,  to_number()와 같은 내장 함수에서 입력 인자로 숫자 형태가 와야 하는데 문자열이 온 경우에서 발생한다. 숫자형에 맞는 데이터를 사용하도록 해야 한다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">(X) select to_number (&#39;A&#39;) from dual;</pre>
</div></div><p> </p><h2 id="id-자주발생하는오류메세지-Invalidcharactervalueforcastspecification(SQLCODE=-331893)">Invalid character value for cast specification (SQLCODE=-331893)</h2><p>숫자 형의 호스트 변수에 문자열을 담아 처리되는 경우 발생한다. 칼럼 타입에 맞는 호스트 변수를 선언하도록 한다.</p><h2 id="id-자주발생하는오류메세지-Invalidcursorstate.(SQLCODE=-331822)orFunctionsequenceerror(SQLCODE=-331796)"><span style="color: rgb(0,0,0);">Invalid cursor state. (SQLCODE=-331822) or Function sequence error (SQLCODE= -331796)</span></h2><p>이 에러는 Cursor를 사용하기 위해 지켜야 할 순서가 올바르게 수행되지 않을 경우 발생한다. 혹은, 이미 데이터를 모두 읽은 cursor이거나 close된 cursor인데 다시 fetch를 부르는 경우도 이 에러가 발생한다.</p><h2 id="id-자주발생하는오류메세지-Thecursormustbeopenedforfetch(SQLCODE=-1)orThecursordoesnotexist(SQLCODE=-589857)">The cursor must be opened for fetch (SQLCODE=-1) or The cursor does not exist (SQLCODE=-589857)</h2><p>일반적인 Cursor의 사용은 (PREPARE-&gt;DECLARE-&gt;OPEN-&gt;FETCH-&gt;CLOSE)의 순서를 거쳐야 한다.  이 에러는 정상적으로 DECLARE/OEPN되지 않은 cursor를 FETCH하려고 시도하는 경우 에러가 발생한다.</p><h2 id="id-자주발생하는오류메세지-Notenoughinsertvalues(SQLCODE=-200787)">Not enough insert values (SQLCODE=-200787)</h2><p>INSERT구문에서 명시된 칼럼 개수와 호스트 변수의 개수가 일치하지 않을 경우 발생한다.</p><h2 id="id-자주발생하는오류메세지-Thetablespacedoesnothaveenoughfreespace(SQLCODE=-69685or-69923)">The tablespace does not have enough free space (SQLCODE=-69685 or -69923)</h2><p>트랜잭션이 진행되는 과정에서 테이블스페이스의 용량이 모두 사용되어 공간이 없는 경우이다. 이 경우에는 해당 디스크 테이블스페이스의 경우는 데이터파일을 추가함으로 공간을 확보하고 메모리 테이블스페이스의 경우에는 불필요한 데이터의 삭제 또는 Compaction과정 등을 통해 가용 공간을 확보해야 한다.</p><h2 id="id-자주발생하는오류메세지-Inputliteralisnotlongenoughfordateformat.(SQLCODE=-135218)">Input literal is not long enough for date format. (SQLCODE=-135218)</h2><p>날짜 함수에 입력된 문자열이 너무 짧은 경우 발생한다. 입력된 데이터에 오류가 없는지 확인해야 한다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">select TO_DATE(&#39;10123&#39;, &#39;yyyymmdd&#39;) from DUAL</pre>
</div></div><h2 id="id-자주발생하는오류메세지-Literalsintheinputdonotmatchformatstring.(SQLCODE=-135224)"><span style="color: rgb(0,0,0);">Literals in the input do not match format string. (SQLCODE=-135224)</span></h2><p>날짜 함수에서 입력된 날짜의 문자열과 날짜 형식이 일치하지 않는 경우 발생한다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">select TO_DATE (&#39;2010123&#39;, &#39; yyyy-mmdd&#39;) from DUAL // 형식 중에 yyyy-mm에 오류</pre>
</div></div><p> </p><h2 id="id-자주발생하는오류메세지-Thetransactionisalreadyactive.(SQLCODE=-266311or-266312)">The transaction is already active. (SQLCODE=-266311 or -266312)</h2><p>세션 단위로 Commit-mode를 조정할 수 있는데 이 과정에서 아직, Commit/Rollback 되지 않은 트랜잭션이 존재하는 상태에서 Auto-Commit으로 변경하는 경우 발생한다. 따라서, 세션의 속성을 변경하는 과정에서 에러가 발생할 경우 이전에 발생한 트랜잭션의 존재 여부를 먼저 확인해 보도록 한다. 혹은, Commit/Rollback을 실행한 이후에 세션의 속성을 변경하도록 한다. 간혹, 쓰레드 프로그램 및 Connection Pool을 구현하여 사용하는 경우에서 연결 객체에 대한 사용자 관리 (즉, autocommit/NonAutoCommit을 혼용하여 사용하는 경우들)가 부주의한 경우 발생할 수 있다.</p><h2 id="id-자주발생하는오류메세지-Therowalreadyexistsinauniqueindex.(SQLCODE=-69720)">The row already exists in a unique index. (SQLCODE=-69720)</h2><p>INSERT 혹은 UPDATE 구문에서 접근하거나 변경하는 값이 이미 primary-key 또는 unique index상에 데이터가 존재하는 경우이다. 이 경우는 조회를 통해 이미 해당하는 데이터 값이 존재하는지 확인하도록 한다.</p><h2 id="id-자주발생하는오류메세지-Unabletoinsert(orupdate)NULLintoNOTNULLcolumn.(SQLCODE=-200790)">Unable to insert (or update) NULL into NOT NULL column. (SQLCODE=- 200790)</h2><p>INSERT 혹은 UPDATE 구문에서 입력하는 데이터 값 중에 칼럼이 NOT NULL인데 NULL값을 넣으려고 하는 경우 발생한다. 데이터 값들을 추적하여 NULL인 데이터가 발생하지 않도록 하거나 칼럼의 NOT NULL Constraints를 적절하게 변경해야 한다.</p><h2 id="id-자주발생하는오류메세지-Indicatorvariablerequiredbutnotsupplied.(SQLCODE=-331841or-594101or594103)">Indicator variable required but not supplied. (SQLCODE=-331841 or -594101 or 594103)</h2><p>DB로부터 호스트 변수에 담긴 값이 NULL인 경우 이 에러가 발생한다. 이 에러는 SQL_SUCCESS_WITH_INFO로 리턴 된다. 즉, 넘겨준 부분이 NULL인 상태임을 인지 시켜 주는 오류이다. (실제 변수에는 어떤 값이 들어 있을지 보장할 수 없다.)<br />이 오류를 없애기 위해서는 칼럼에 NVL처리를 하거나 또는, 별도의 int 타입의 indicator변수를 사용하여 호스트 변수에 사용하는 방법으로 해결할 수 있다. 또는 apre옵션 중  -unsafe_null 옵션을 사용할 수도 있다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">1) apre –unsafe_null  로 컴파일 한다.
 
2) SELECT NVL (Column, &#39;N/A&#39;) from T1 와 같이 NVL로 대체 값을 넣는 방법
 
3) indicator 변수를 사용하는 방법
    EXEC SQL BEGIN  DECLARE SECTION;
      char  H_var [20 + 1];
      int    H_indi;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT Column  INTO :H_var indicator :H_indi;</pre>
</div></div><p> </p><h2 id="id-자주발생하는오류메세지-Client&#39;squeryexceededintheexecutiontimelimitation.(SQLCODE=-4164)">Client's query exceeded in the execution time limitation. (SQLCODE=-4164)</h2><p>질의를 수행하는 과정의 시간이 지정된 시간을 초과하는 경우 해당 질의는 이 에러가 리턴 된다. 문서에서 설명한 질의의 실행계획을 확인하고 필요한 튜닝 조치를 취하거나 만일, 이미 적절한 조치가 됐음에도 전체 처리해야 할 데이터의 양에 의한 경우라면 다음과 같이 수행한 후 질의를 처리하도록 한다.<br />EXEC SQL ALTER SESSION SET QUERY_TIMEOUT = 0;<br />&quot;0&quot;으로 설정하면 질의 처리에 대한 Timeout 설정에 상관 없이 수행이 지속된다. 단, 이렇게 할 경우 해당 쿼리가 완료될 때까지는 리소스를 대량으로 점유할 수 있음으로 변경에는 신중하게 결정할 것을 권고한다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">EXEC SQL ALTER SESSION SET QUERY_TIMEOUT = 0;</pre>
</div></div><p> </p><h2 id="id-자주발생하는오류메세지-Communicationlinkfailure.(SQLCODE=-331843or-331855)">Communication link failure. (SQLCODE=-331843 or -331855)</h2><p>질의를 처리하는 과정에서 서버 또는 네트웍의 오류로 인해 연결이 단절되는 경우 발생한다. 이 경우 먼저 $ALTIBASE_HOME/trc/altibase_boot.log 에 timeout과 관련된 로그가 기록되었는지 확인한다. 일반적으로 2개의 경우가 발생한다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">[Notify : Fetch Timeout] Session Closed by Server : Session ID = 44
[Notify : UTrans Timeout] Session Closed by Server : Session ID = 44</pre>
</div></div><p><br />Fetch Timeout은 DBMS서버와 프로그램 간의 통신의 간격이 60초로 제한되어 있는데 이를 넘은 경우 서버에서 강제적으로 세션을 단절하는 경우를 의미한다.<br />UTrans Timeout은 사용자가 변경 트랜잭션을 발생한 후 Commit/Rollback을 수행하지 않은 채 유지하는 시간의 간격이 3600초로 제한되어 있는데 이를 초과한 경우 세션이 단절되게 되는 경우를 의미한다. 2가지 모두 다음과 같이 제한 값을 변경할 수 있다.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">EXEC SQL ALTER SESSION SET  FETCH_TIMEOUT = 0;

EXEC SQL ALTER SESSION SET UTRANS_TIMEOUT = 0;</pre>
</div></div><p><br />&quot;0&quot; 값으로 설정하면 해당 제한이 적용되지 않도록 동작한다. 다만, 개발자가 위와 같이 설정한 경우 QUERY_TIMEOUT의 경우와 마찬가지로 해당 트랜잭션이 지속되는 동안은 DBMS내부의 리소스를 계속 점유하고 경우에 따라 장애를 유발할 가능성이 있기 때문에 위의 문제를 원천적으로 해결할 방안을 모색할 것을 권고한다.<br />일부 네트웍의 문제 또는 L4, 방화벽의 Timeout등의 설정으로 altibase_boot.log에 오류 없이 단절되는 경우도 있기 때문에 이것은 별도의 PBT(Problem Tracking)과정을 통해 원인을 찾아야 한다.</p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 23, 2021 09:57</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
