<!DOCTYPE html>
<html>
    <head>
        <title>Technical Documents(English) : 2. Considerations when Developing</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Technical Documents(English)</a></span>
                            </li>
                                                    <li>
                                <span><a href="Home_557064.html">Home</a></span>
                            </li>
                                                    <li>
                                <span><a href="Altibase-Development-Guide_14058519.html">Altibase Development Guide</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Technical Documents(English) : 2. Considerations when Developing
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
    
            Created by <span class='author'> richard.nahm	</span>, last modified on Feb 18, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1624409360171 {padding: 0px;}
div.rbtoc1624409360171 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1624409360171 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1624409360171'>
<ul class='toc-indentation'>
<li><a href='#id-2.ConsiderationswhenDeveloping-ChoosingDBMSconnectiontype'>Choosing DBMS connection type</a>
<ul class='toc-indentation'>
<li><a href='#id-2.ConsiderationswhenDeveloping-①ChoosingALTIBASEconnectiontype'>① Choosing ALTIBASE connection type</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-②Auto-commitmodeisthedefaultsettingforALTIBASE'>② Auto-commit mode is the default setting for ALTIBASE</a></li>
</ul>
</li>
<li><a href='#id-2.ConsiderationswhenDeveloping-Threadprogram,connectionpoolmanagement'>Thread program, connection pool management</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-Checkpointswhendisconnectinganapplication'>Checkpoints when disconnecting an application</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-SessionTimeout'>Session Timeout</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-ConsiderationswhenusingSELECTCursor'>Considerations when using SELECT Cursor</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-CheckingSQLError'>Checking SQL Error</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-ConsiderationsforLOBtype'>Considerations for LOB type</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-UsingPreparedStatement'>Using Prepared Statement</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-SQLTuning'>SQL Tuning</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-Cautionsduringthebulkchangeoperation'>Cautions during the bulk change operation</a>
<ul class='toc-indentation'>
<li><a href='#id-2.ConsiderationswhenDeveloping-①Possibilityofmemoryincreaseincaseofmasschangeofmemorytable'>① Possibility of memory increase in case of mass change of memory table</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-②Continuousincreaseoftransactionlogfilesbyperformingbulkchangeoperation'>② Continuous increase of transaction log files by performing bulk change operation</a></li>
<li><a href='#id-2.ConsiderationswhenDeveloping-③Possibilityofdead-lockoccurrenceanddelayinthereflectioninareplicationenvironment'>③ Possibility of dead-lock occurrence and delay in the reflection in a replication environment</a></li>
</ul>
</li>
</ul>
</div></p><hr /><p>This chapter describes considerations in the development stage are summarized and explained.</p><h2 id="id-2.ConsiderationswhenDeveloping-ChoosingDBMSconnectiontype"><strong>Choosing DBMS connection type</strong></h2><h3 id="id-2.ConsiderationswhenDeveloping-①ChoosingALTIBASEconnectiontype">① <strong style="color: rgb(51,51,51);font-size: 14.0px;">Choosing ALTIBASE connection type</strong></h3><div><p> </p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th class="confluenceTh"><div class="tablesorter-header-inner"><p>Connection Type</p></div></th><th class="confluenceTh"><div class="tablesorter-header-inner"><p>Description</p></div></th></tr></thead><tbody><tr><td class="confluenceTd"><p>CONNTYPE=1</p></td><td class="confluenceTd"><p>TCP/IP connection type, normal connection method</p></td></tr><tr><td class="confluenceTd"><p>CONNTYPE=2</p></td><td class="confluenceTd"><p>UNIX Domain Socket connection type, only available in the local server</p></td></tr><tr><td class="confluenceTd"><p>CONNTYPE=3</p></td><td class="confluenceTd"><p>IPC connection type, only available in the local server</p></td></tr></tbody></table></div><p>The CONNTYPE=n means the connection type, and when the connection string is specified in the program, the user can specify it explicitly. If DBMS and application are located on separate servers, only CONNTYPE=1 can be used. However, if DBMS and application run on the same server, it is recommended to select CONNTYPE=2, 3 to reduce the cost of communication.</p><h3 id="id-2.ConsiderationswhenDeveloping-②Auto-commitmodeisthedefaultsettingforALTIBASE">② Auto-commit mode is the default setting for ALTIBASE</h3><p>JDBC connects in auto-commit mode according to the standard specification. Other applications are determined by the &quot;AUTO_COMMIT&quot; property in the $ALTIBASE_HOME/conf/altibase.properties file by default unless the user changes. If this property value is &quot;1&quot;, it operates in auto-commit mode. (Auto-commit means that the commit is automatically performed after the change transaction is completed normally)</p><p>Therefore, if the user wants to change this property value to Non auto-commit, ALTIBASe must be restarted after changing the property value to &quot;0&quot; in the configuration file. If the user is controlling by session, the user can execute the following SQL after connecting to the DBMS.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: sql; gutter: false" style="font-size:12px;">ALTER SESSION SET AUTOCOMMIT = FALSE; (In the case of Java, it is controlled using setAutoCommit function.)</pre>
</div></div><p>(For the ALTER SYSTEM command, it can be changed in real time to reflect the entire system, but it will be restored after restarting, so it is recommended to modify and restart the property that affects the entire property through the property file.)</p><h2 id="id-2.ConsiderationswhenDeveloping-Threadprogram,connectionpoolmanagement"><strong>Thread program, connection pool management</strong></h2><p>In a thread environment program, if multiple threads share one connection, the developer must perform concurrency control for the connection. ALTIBASE exchanges the promised protocols during processing session-server communication. Generally, it goes through the process of <span lang="en">PAREBINDEXECUTE</span>FETCH, etc. In this situation, an error occurs in the process that the other protocol is interrupted and the session is incorrectly processed.</p><div><p> </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">Communication link failure (EXEC-&gt;INVL)

Communication link failure (PREP-&gt;EXEC)

Invalid request to process the SQL statement</pre>
</div></div><p>The above errors occur when one connection is executing another SQL in the absence of concurrency control while executing any SQL while using the thread program or connection pool. Therefore, when the above error occurs, first, it is necessary to check whether concurrency control or connection processing in the program written by the developer does not cause an error to interrupt.</p><p>(Occasionally, if the timer is set in the user program, it may occur even if it is not a concurrency control problem as described above. For example, another SQL statement is executed while the FETCH protocol is not yet completed because the timer operates during the SELECT~FETCH process. if it is set, the above error may occur.)</p><h2 id="id-2.ConsiderationswhenDeveloping-Checkpointswhendisconnectinganapplication"><strong>Checkpoints when disconnecting an application</strong></h2><p>The SQL statements executed in the program are prepared in individual programs and servers. It is recommended to develop code to release resources when these SQL statements are used. In particular, in the case of Java, memory increase may occur, so the following code is important.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">Connection con = pool.getConnection();
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery();
 
try
{
   ….
} exception ()
{
   …..
}
finally
{
    // Release all resource used within the program.
    rs.close();
    stmt.close();
    conn.close();
}</pre>
</div></div><p>In the case of development such as CLI/ODBC, SQL_DROP must be executed with the SQLFreeStmt function at the end of use after the memory is allocated with SQLAllocStmt. If it is reused, use the SQL_CLOSE option. Otherwise, if it is completely disabled, use the SQL_DROP option to explicitly disable it.</p><h2 id="id-2.ConsiderationswhenDeveloping-SessionTimeout"><strong>Session Timeout</strong></h2><div>A session is the connection of the program connected to the DB. Each session is managed by the timeout policy of ALTIBASE. ALTIBASE provides five timeout policies. (The color shown below can be controlled only in the connection string.)</div><div class="table-wrap"><table class="confluenceTable"><thead><tr><th class="confluenceTh"><div class="tablesorter-header-inner"><p> </p></div></th><th class="confluenceTh"><div class="tablesorter-header-inner"><p>Session state after an error</p></div></th><th class="confluenceTh"><div class="tablesorter-header-inner"><p><strong>Description</strong></p></div></th></tr></thead><tbody><tr><td class="confluenceTd"><p>CONNECTION_TIMEOUT</p></td><td class="confluenceTd"><p>Disconnected</p></td><td class="confluenceTd">Option to set the timeout in the blocked state between transmission/reception on the network while connected to the DB<p> </p></td></tr><tr><td class="confluenceTd"><p>TIMEOUT</p></td><td class="confluenceTd"><p>Disconnected</p></td><td class="confluenceTd">Occurs when the time to try to connect to the DB exceeds this setting<p> </p></td></tr><tr><td class="confluenceTd"><p>QUERY_TIMEOUT</p></td><td class="confluenceTd"><p>Connected</p></td><td class="confluenceTd"><p>Occurs when the total time to execute a query while connected to the DB exceeds this setting</p></td></tr><tr><td class="confluenceTd"><p>FETCH_TIMEOUT</p></td><td class="confluenceTd"><p>Disconnected</p></td><td class="confluenceTd"><p>Occurs when the time interval during which the FETCH protocol occurs exceeds this value after executing the SELECT statement while connected to the DB</p></td></tr><tr><td class="confluenceTd"><p>IDLE_TIMEOUT</p></td><td class="confluenceTd"><p>Disconnected</p></td><td class="confluenceTd"><p>Occurs when idle time without executing any query while connected to DB exceeds this setting</p></td></tr><tr><td class="confluenceTd"><p>UTRANS_TIMEOUT</p></td><td class="confluenceTd"><p>Disconnected</p></td><td class="confluenceTd"><p>Occurs when this setting value is exceeded until commit/rollback is executed after executing the query while connected to the DB (execution query is rolled back)</p></td></tr></tbody></table></div><p>If the user has a 5-second timeout for a connection attempt and a blocking phenomenon on the network occurs, and there is no response with 30 seconds if the user wants to disconnect the connection, add the option to the connection string as follows.</p><div class="panel" style="border-width: 1px;"><div class="panelContent">
<p>DSN=127.0.0.1;CONNTYPE=2;<span style="color: red;">TIMEOUT=5;CONNECTION_TIMEOUT=30</span> </p>
</div></div><p>Other TIMEOUT settings operate in the unit set in $ALTIBASE_HOME/conf/altibase.properties, and can be controlled by executing the following query for each session. (When it set to &quot;0&quot;, it operates as infinite)</p><div><div class="syntaxhighlighter nogutter  sql"><p> </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: sql; gutter: false" style="font-size:12px;">ALTER SESSION SET QUERY_TIMEOUT = 30 (Unit: second)
ALTER SESSION SET FETCH_TIMEOUT = 30</pre>
</div></div><p> </p></div></div><p>If the error by TIMEOUT occurs, the following error can be checked in the application.</p><div class="table-wrap"><table class="confluenceTable"><thead><tr><th class="confluenceTh"><div class="tablesorter-header-inner"><p> </p></div></th><th class="confluenceTh"><div class="tablesorter-header-inner"><p>Error Message</p></div></th></tr></thead><tbody><tr><td class="confluenceTd"><p>CONNECTION_TIMEOUT</p></td><td class="confluenceTd"><p>Connection time out</p></td></tr><tr><td class="confluenceTd"><p>FETCH_TIMEOUT</p></td><td class="confluenceTd"><p>The session has been closed by the server</p></td></tr><tr><td class="confluenceTd"><p>IDLE_TIMEOUT</p></td><td class="confluenceTd"><p>The session has been closed by the server</p></td></tr><tr><td class="confluenceTd"><p>QUERY_TIMEOUT</p></td><td class="confluenceTd"><p>Client's query exceeded in the execution time limitation</p></td></tr><tr><td class="confluenceTd"><p>TIMEOUT</p></td><td class="confluenceTd"><p>Client unable to establish connection</p></td></tr><tr><td class="confluenceTd"><p>UTRANS_TIMEOUT</p></td><td class="confluenceTd"><p>The session has been closed by the server</p></td></tr></tbody></table></div><p>TIMEOUT-related errors are also recorded in $ALTIBASE_HOME/trc/altibase_boot.log.</p><div class="panel" style="border-width: 1px;"><div class="panelContent">
[2010/07/06 13:10:35] [Thread-182894171744] [Level-1]<br />[Notify : <span style="color: red;">UTrans Timeout</span>] Session Closed by Server : Session ID = 53<br />CLIENT_INFO =&gt; TCP 127.0.0.1:3992(PID : 13645)<br />Time Limit =&gt; 3<br />Running Time =&gt; 5<br />Last Query =&gt; insert into t1 select * from t1 limit 1<br />Caused by Transaction =&gt; 82368
</div></div><p>If the above log is recorded in altibase_boot.log, the developer must check and take action to determine why the Timeout error occurred.</p><p>Each cause is the same as described above, so if it occurs as a bottleneck of query processing, the corresponding query should be tuned. If UTrans_Timeout occurs as in the above example, commit/rollback is not performed after a change transaction occurs. The transaction control part of the program must be corrected/corrected.</p><p>If it is difficult for the user to solve it with the above instruction and need to force the processing, the TIMEOUT setting value for the DB session of the program should be processed rather than the property value of the entire DB.</p><h2 id="id-2.ConsiderationswhenDeveloping-ConsiderationswhenusingSELECTCursor"><strong>Considerations when using SELECT Cursor</strong></h2><p>When implementing a SELECT statement using CURSOR, the user must perform an error check on the FETCH statement and close the CURSOR after an error occurs or after reading all data. If the user tries to FETCH a CURSOR that has already been read or try to work on a CURSOR that is not closed yet, an unintended error may occur. After using CURSOR, you must CLOSE normally.</p><p>Another consideration is that in the case of ALTIBASE, if COMMIT/ROLLBACK occurs during FETCH, the open CURSOR is automatically closed. Therefore, in order to create another transaction while during FETCH, a separate DB session needs to be created and a separate transaction needs to be processed with the session or perform a COMMIT/ROLLBACK after all the FETCH is completed.</p><p>However, if there are a large number of records to be processed, it is recommended to implement a structure in which separate sessions are established and processed rather than bulk changes. If the number of records to be changed must be bound in one transaction, it is recommended to develop a program so that conditions can be separated and processed.</p>    <div class="aui-message hint shadowed information-macro">
                            <span class="aui-icon icon-hint">Icon</span>
                <div class="message-content">
                            <p>Refer to the conditions for the bulk change operation below.</p>
                    </div>
    </div>
<h2 id="id-2.ConsiderationswhenDeveloping-CheckingSQLError"><strong>Checking SQL Error</strong></h2><p>It is recommended that developers of the ALTIBASE environment to check the SQL error after all queries are processed. In particular, the following case must be checked in order to find errors.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: sql; gutter: false" style="font-size:12px;">EXEC SQL PREPARE ….
EXEC SQL EXECUTE ….
If (SQLCODE != SQL_SUCCESS)
   Error_log ();
 
Or,
EXEC SQL DECLARE CURSOR…
EXEC SQL OPEN ….
If (SQLCODE != SQL_SUCCESS)
   Error_log ();</pre>
</div></div><p>In the above code, there is no error checking after performing PREPARE or DECLARE CURSOR. In this case, if the PREPARE (DECLARE CURSOR) step causes an error, the SQL error in the EXECUTE (OPEN) step would cause an error such as &quot;Not defined (XX)&quot;, and despite the fact that it was actually caused by the PREPARE (DECLARE CURSOR) error, but the error cannot be accurately confirmed.</p><p>ALTIBASE also sends a query to the server for the execution of PREPARE (DECLARE CURSOR), so it performs query processing up to the step before executes it.</p><p>It is important to note that SQL error checking must be performed when all SQL processing statements are entered.</p><p> </p><div><h2 id="id-2.ConsiderationswhenDeveloping-ConsiderationsforLOBtype"><strong>Considerations for LOB type</strong></h2><p>When querying for LOB type in ALTIBASE, it must be operated in non-auto-commit mode. The following error may occur in auto-commit mode.</p><div><p> </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">[ERR-91101 : Connection is in autocommit mode. One can not operate on LOB datas with autocommit mode on.]</pre>
</div></div><p>It does not matter if the query is executed with the LOB in the column of the table, but the above error occurs when the LOB type is included in the SELECT target clause. Therefore, when querying the LOB type, it must be executed after changing the properties of the session to non-auto-commit mode.</p><p>However, in the case of using ALTIBASE HDB 6.3.1 or later JDBC driver, LOB type data can be queried in auto-commit mode by setting the transaction commit mode to be controlled on the client-side. How to set the transaction commit mode on the client-side of the JDBC is as follows.</p><ul><li>Example of altibase_cli.ini</li></ul><div class="panel" style="border-width: 1px;"><div class="panelContent">
[ DataSource ]<br class="atl-forced-newline" />Server=192.168.1.1<br class="atl-forced-newline" />Port=20300<br class="atl-forced-newline" />User=SYS<br class="atl-forced-newline" />Password=MANAGER<br class="atl-forced-newline" />AlternateServers=(192.168.1.2:20300,192.168.1.3:20300)<br class="atl-forced-newline" />ConnectionRetryCount=3<br class="atl-forced-newline" />ConnectionRetryDelay=5<br class="atl-forced-newline" />LoadBalance = On<br class="atl-forced-newline" />SessionFailOver = Off<br class="atl-forced-newline" /><span style="color: red;">ClientSide_Auto_Commit = On</span>
</div></div><h2 id="id-2.ConsiderationswhenDeveloping-UsingPreparedStatement"><strong>Using Prepared Statement</strong></h2><p>ALTIBASE stores the execution plan of internally executed queries to speed up the performance of query processing. However, if a query of PREPARE/EXECUTE is executed every time, the execution plan that has already been PREPARE is used internally, but because the network cost to execute PREPARE is queried every time, it is recommended to write the following code to prevent the downgrade of performance.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>( O )</p><div><p> </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2"><code class="java plain">Prepare statement</code></div><div class="line number2 index1 alt1"><code class="java keyword">while</code> <code class="java plain">(</code><code class="java value">1</code><code class="java plain">)</code></div><div class="line number3 index2 alt2"><code class="java plain">{</code></div><div class="line number4 index3 alt1"><code class="java plain">Execute statement</code></div><div class="line number5 index4 alt2"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div></td><td class="confluenceTd"><p>( X )</p><div><p> </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2"><code class="java keyword">while</code> <code class="java plain">(</code><code class="java value">1</code><code class="java plain">)</code></div><div class="line number2 index1 alt1"><code class="java plain">{</code></div><div class="line number3 index2 alt2"><code class="java plain">Prepare statement</code></div><div class="line number4 index3 alt1"><code class="java plain">Execute statement</code></div><div class="line number5 index4 alt2"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div></td></tr></tbody></table></div><p>There is a DB development library called OTL among open sources (Oracle, odbc template library). This library processes all queries in the form of prepare/execute every time. However, once the streaming option is activated, once prepared queries are only processed in the form of executing. The developer can query with the use of these tuning elements (reducing the network transmission cost). In the process, the dynamic should be minimized as much as possible and make sure that it is not preparing the same query every time.</p><div><div class="syntaxhighlighter nogutter  c"><p> </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">sprintf (sql,  “INSERT INTO t1 VALUES (%d, %d)”, szNum1, szNum2);
EXEC SQL Prepare S for :sql;
EXECUTE S;</pre>
</div></div><p> </p></div></div><p>The above code creates an SQL statement to be executed each time, prepares it, and executes it. In this case, the following would be reasonable.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: java; gutter: false" style="font-size:12px;">EXEC SQL INSERT INTO t1 VALUES (:szNum1, :szNum2);</pre>
</div></div><p> </p><div><h2 id="id-2.ConsiderationswhenDeveloping-SQLTuning"><strong>SQL Tuning</strong></h2><div><p>When developing operations related to DB operation, there are cases where query processing is slow. Or, there are cases where the query was processed quickly in the test environment, but the query process is very slow in the integration test or operation stage. This can be seen as a case where the developer or DBA neglects the verification or testing process of the execution plan for all queries executed.</p><p>ALTIBASE can check the query processing process, that is, the execution plan as follows.</p><div><div class="syntaxhighlighter nogutter  sql"><p> </p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="theme: Confluence; brush: sql; gutter: false" style="font-size:12px;">ALTER SESSION SET EXPLAIN PLAN = ON;</pre>
</div></div><p> </p></div></div>After executing the above command, the execution plan can be checked by executing a query in iSQL or a utility such as AdminCenter2.<div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>iSQL&gt; ALTER SESSION SET EXPLAIN PLAN = ON;<br class="atl-forced-newline" />Alter success.<br class="atl-forced-newline" />iSQL&gt; SELECT a, COUNT(*) FROM t1 WHERE a = 1 GROUP BY a;<br class="atl-forced-newline" />A COUNT<br class="atl-forced-newline" />------------------------------------<br class="atl-forced-newline" />1 262145<br class="atl-forced-newline" />1 row selected.<br class="atl-forced-newline" /><br class="atl-forced-newline" /><span style="color: red;">------------------------------------------------------------</span><br class="atl-forced-newline" /><span style="color: red;">PROJECT ( COLUMN_COUNT: 2, TUPLE_SIZE: 16 )</span><br class="atl-forced-newline" /><span style="color: red;">GROUP-AGGREGATION ( ITEM_SIZE: 32, GROUP_COUNT: 1, BUCKET_COUNT: 1024, ACCESS: 1, SELF_ID: 3, REF_ID: 2 )</span><br class="atl-forced-newline" /><span style="color: red;">SCAN ( TABLE: T1, FULL SCAN, ACCESS: 262145, SELF_ID: 2 )</span><br class="atl-forced-newline" /><span style="color: red;">------------------------------------------------------------</span></p></td></tr></tbody></table></div><p>We can see that the above execution plan FULL SCAN table T1 and accessed 262,145 records. If the index exists and the condition to use the index is specified, the following might be displayed.</p><p>------------------------------------------------------------<br />PROJECT ( COLUMN_COUNT: 1, TUPLE_SIZE: 4 )<br /><span style="color: red;">SCAN ( TABLE: T1, INDEX: IDX_T1, ACCESS: 2, SELF_ID: 2 )</span><br />------------------------------------------------------------</p></div></div><p>For more information on SQL tuning, please refer to the “ALTIBASE SQL Tuning Guide” document.</p><h2 id="id-2.ConsiderationswhenDeveloping-Cautionsduringthebulkchangeoperation"><strong>Cautions during the bulk change operation</strong></h2><p>Since general bulk change operation has a high load not only in ALTIBASE but also in other DBMS, there are precautions required for each vendor. ALTIBASE requires the following cautions.</p><h3 id="id-2.ConsiderationswhenDeveloping-①Possibilityofmemoryincreaseincaseofmasschangeofmemorytable">① Possibility of memory increase in case of mass change of memory table</h3><p>ALTIBASE supports the MVCC (Multi-Version Concurrency Control) technique. In the MVCC technique, when a change occurs, the same record is duplicated in the empty space of the table to make the change. If 10 million changes are made, memory increases due to 10 million copies will inevitably occur. (Of course, the increased area is reused as data or replication area, but the memory is not released in real time.)</p><h3 id="id-2.ConsiderationswhenDeveloping-②Continuousincreaseoftransactionlogfilesbyperformingbulkchangeoperation">② Continuous increase of transaction log files by performing bulk change operation</h3><p>A large number of changes require a redo log for each change target record to be recorded in the transaction log file. Therefore, it is necessary to record the redo log of all the records that are changed in one transaction, but if the scope of this target is large, as many transaction log files are created as well. (ALTIBASE deletes the transaction log file at the time of the checkpoint. If there is information on which the transaction is ongoing in the log file, it cannot be deleted, and there is a possibility of a disk shortage failure due to the log file increase.)</p><h3 id="id-2.ConsiderationswhenDeveloping-③Possibilityofdead-lockoccurrenceanddelayinthereflectioninareplicationenvironment">③ Possibility of dead-lock occurrence and delay in the reflection in a replication environment</h3></div></div><div><p>In a replication environment, as described above, the change information of all records changed by one transaction is transmitted to the other server.</p><p>In this process, a lock is held for the corresponding record of the other server. If the other server changes the record in the same range, a deadlock may occur between the transaction caused by the redundancy log and the transaction occurring in the other server itself.</p></div></div></div>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 23, 2021 09:49</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
