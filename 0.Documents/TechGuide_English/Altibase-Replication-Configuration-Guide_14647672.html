<!DOCTYPE html>
<html>
    <head>
        <title>Technical Documents(English) : Altibase Replication Configuration Guide</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Technical Documents(English)</a></span>
                            </li>
                                                    <li>
                                <span><a href="Home_557064.html">Home</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Technical Documents(English) : Altibase Replication Configuration Guide
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
    
            Created by <span class='author'> richard.nahm	</span>, last modified on Feb 22, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1624409363851 {padding: 0px;}
div.rbtoc1624409363851 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1624409363851 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1624409363851'>
<ul class='toc-indentation'>
<li><a href='#AltibaseReplicationConfigurationGuide-Overview'>Overview</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-HighAvailability'>High Availability</a>
<ul class='toc-indentation'>
<li><a href='#AltibaseReplicationConfigurationGuide-Node'>Node</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-Fail-over'>Fail-over</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-PlanforHighAvailability'>Plan for High Availability</a></li>
</ul>
</li>
<li><a href='#AltibaseReplicationConfigurationGuide-ConceptofReplication'>Concept of Replication</a>
<ul class='toc-indentation'>
<li><a href='#AltibaseReplicationConfigurationGuide-Thebasicconceptofreplication'>The basic concept of replication</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-Sender'>Sender</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-Receiver'>Receiver</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-Problemsthatcanoccurinareplicationenvironment'>Problems that can occur in a replication environment</a></li>
</ul>
</li>
<li><a href='#AltibaseReplicationConfigurationGuide-EfficientReplicationConfiguration'>Efficient Replication Configuration</a>
<ul class='toc-indentation'>
<li><a href='#AltibaseReplicationConfigurationGuide-Off-LineReplicator'>Off-Line Replicator</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-ServiceConfigurationusingtheHASolution'>Service Configuration using the HA Solution</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-DataDelayConsiderations'>Data Delay Considerations</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-Serviceconfigurationtopreventdataconflict'>Service configuration to prevent data conflict</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-Replicationconfigurationconsideringdataconsistency'>Replication configuration considering data consistency</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-DesignofN-WayReplication'>Design of N-Way Replication</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-ImportanceofReplicationDesign'>Importance of Replication Design</a></li>
</ul>
</li>
<li><a href='#AltibaseReplicationConfigurationGuide-AdditionalConsiderationsforReplicationConfiguration'>Additional Considerations for Replication Configuration</a>
<ul class='toc-indentation'>
<li><a href='#AltibaseReplicationConfigurationGuide-ConsiderationsforDiskCapacity'>Considerations for Disk Capacity</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-CautionforBulkChange'>Caution for Bulk Change</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-SenderStatusMonitoring'>Sender Status Monitoring</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-ReplicationDedicatedLine'>Replication Dedicated Line</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-ParallelApplierOption'>Parallel Applier Option</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-SequenceReplication'>Sequence Replication</a></li>
<li><a href='#AltibaseReplicationConfigurationGuide-ConstraintstoConsiderforReplicationConfiguration'>Constraints to Consider for Replication Configuration</a></li>
</ul>
</li>
<li><a href='#AltibaseReplicationConfigurationGuide-Summary'>Summary</a></li>
</ul>
</div></p><h1 id="AltibaseReplicationConfigurationGuide-Overview">Overview</h1><hr /><p>In a system operating environment that provides non-stop service, the following should be considered.</p><ul><li>Ensure availability in case of failure</li><li>Configuration and extension of the system considering performance</li></ul><p>As a method to implement these, a disk sharing method, a replication method using a network, and a switching method using an HA solution are widely used in the field.</p><p>The high-availability (HA) architecture of Altibase considers performance and proposes a network-based data replication configuration.</p><p>This document describes replication provided by Altibase and an efficient system configuration based on Altibase. (Altibase does not support the high availability method of the disk sharding among the methods specified above.)</p><p>This document was prepared based on ALTIBASE version 7 or later.</p>    <div class="aui-message hint shadowed information-macro">
                            <span class="aui-icon icon-hint">Icon</span>
                <div class="message-content">
                            <p>For errors and improvements related to this document, please contact the technical support portal or technical support center.</p><ul><li>Technical support portal: <a class="external-link" href="http://support.altibase.com/" rel="nofollow">http://support.altibase.com</a><a class="external-link" href="http://support.altibase.com/en/" rel="nofollow">/en/</a></li><li>Technical support center: 02-2082-1114</li></ul>
                    </div>
    </div>
<h1 id="AltibaseReplicationConfigurationGuide-HighAvailability"><span style="color: rgb(0,0,0);"><br />High Availability</span></h1><hr /><p><span style="color: rgb(0,0,0);"> This section describes the goals and purposes of high availability and explains the pros and cons of the current industry-wide approach of high availability.</span></p><h2 id="AltibaseReplicationConfigurationGuide-Node"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Node</span></span></h2><hr /><p>This refers to each server connected to one or more networks configured to perform the service operated by the user. Each node can serve independently and all nodes can process the same service.</p><h2 id="AltibaseReplicationConfigurationGuide-Fail-over"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Fail-over</span></span></span></h2><hr /><p>This refers to the process of transferring service to another normal node when a failure occurs between nodes configured for service. Fail-over allows only minimal service downtime.</p><h2 id="AltibaseReplicationConfigurationGuide-PlanforHighAvailability">Plan for High Availability</h2><hr /><p>For high availability, the user must configure a service system by grouping two or more nodes for the same or different services. The system must meet the following goals:</p><ol><li>Compared to the environment composed of a single node, there should be no significant performance degradation.</li><li>Only minimal service downtime is allowed in a fail-over situation due to failure.</li></ol><p>High availability requires ensuring that the service system operated by the user exhibits the maximum performance, and in any type of failure, it can be seen that it requires a method that allows the service to immediately resume with minimal downtime. (Goals: high performance and continuous service)</p><p> </p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"><strong>Method</strong></p></td><td class="confluenceTd"><p align="center"><strong>Description</strong></p></td></tr><tr><td class="confluenceTd"><p>Disk sharing method</p></td><td class="confluenceTd"><p>A method of sharing a single DB on a disk accessible to all nodes (sharing DB)</p></td></tr><tr><td class="confluenceTd"><p>Network replication method</p></td><td class="confluenceTd"><p>All nodes own their respective DBs, and the method of transmitting and reflecting changes through the network (each node owns a separate DB)</p></td></tr></tbody></table></div><p>First, let's take a closer look at the disk sharing method.</p><p><img class="confluence-embedded-image" src="attachments/14647672/14778432.png" data-image-src="attachments/14647672/14778432.png"></p><p>In the disk sharing method, each node has its own buffer cache, and a node of the master concept that controls the synchronization of the buffer cache must exist within the entire group. When each node needs to read data that does not exist in its own buffer cache from the shared disk, it requests to read from the master node, and the mast node replicates from that node if there is a node already owned in the buffer cache of the node belonging to the group. This is configured in a form that transmits it or allows the requesting node to read from the disk. In the same case of change, access is possible only if the master node allows the change.</p><p> </p><p>This form may be the best method for data integrity, but has the following problems.</p><ol><li>All nodes cause significant performance degradation due to contention caused by communication with the master node and waiting for access to the buffer.</li><li>Communication equipment for high-speed replication of buffers is required between all nodes. If there is a failure in such communication equipment and line, it may cause an overall failure.</li><li>Even when a failure occurs in the shared disk device, the entire system cannot be serviced.</li></ol><p>On the other hand, the network replication method is based on the operation mode of a single system and the transmission of additional transaction logs. Therefore in terms of performance, it is possible to maintain a performance level of 90% or more compared to a single system because it is not necessary except for the cost of log transmission with the network.</p><p>In addition, even if a specific node in a group fails, it is possible to maintain continuous service because each has a separate DB.</p><p>However, the method of transmitting the transaction log with the network is the difference between the time of the transaction occurring in the local system and the time of the transaction occurring in the other node. Therefore, it is impossible to have a 100% guarantee of consistency of day in two or mode nodes. This problem will be dealt with in detail later.</p><p>Both of the above methods have their own pros and cons. Therefore, the user needs to configure the optimal system with an accurate understanding of each method.</p><p>ALTIBASE is a performance-oriented product, focusing on high availability while guaranteeing maximum performance in the service operation. The below section will describe the concept of replication and how network replication can be used with high availability despite having data consistency problems.</p><h1 id="AltibaseReplicationConfigurationGuide-ConceptofReplication">Concept of Replication</h1><hr /><p>This section describes the concept and operation structure of replication.</p><h2 id="AltibaseReplicationConfigurationGuide-Thebasicconceptofreplication">The basic concept of replication</h2><hr /><p>The structure of ALTIBASE replication is as follows.</p><p><img class="confluence-embedded-image" width="500" src="attachments/14647672/14778433.png" data-image-src="attachments/14647672/14778433.png"> </p><p>Several threads required for transaction processing in ALTIBASE use the storage-manager module. The log thread that uses the SM module plays the role of recording the transaction log required for recovery during transaction processing.</p><p>The basic overall patter is when a transaction log is recorded locally by the SM, the sender reads the recorded transaction log and sends it to the designated node(s), and the receiver of the node analyzes the received log and reflects it back to the receiver's own node that operates in a structure.</p><ul><li>Asynchronous replication using a transaction log-based network.</li><li>Replication configuration can consist of n numbers, and tables included in the replication configuration must have a PK.</li><li>Network for replication can be replicated with n networks for stability.</li></ul><p>Let's take a look at the operation of the Sender and Receiver.</p><h2 id="AltibaseReplicationConfigurationGuide-Sender"><span style="color: rgb(0,0,0);">Sender</span></h2><hr /><p>When a change transaction such as Insert/Update/Delete other than the select statement occurs, information necessary for processing and restoring is recorded. Based on this transaction log, the sender finds out what type of transaction occurred and the value before and after the data change.</p><p>The sender creates a transmission data called xLog based on the read log. It can be seen as a structure containing the following information.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><p align="center"><strong>Description</strong></p></td></tr><tr><td class="confluenceTd"><p align="center">Table</p></td><td class="confluenceTd"><p>The target table must be found in the receiving node.</p></td></tr><tr><td class="confluenceTd"><p align="center">PK</p></td><td class="confluenceTd">The target data must be found in the receiving node.<p> </p></td></tr><tr><td class="confluenceTd"><p align="center">Column</p></td><td class="confluenceTd">The target column must be found in the receiving node.<p> </p></td></tr><tr><td class="confluenceTd"><p align="center">Before Value</p></td><td class="confluenceTd">To compare whether data is the same between the receiving node and the transmitting node.<p> </p></td></tr><tr><td class="confluenceTd"><p align="center">After Value</p></td><td class="confluenceTd"><p>This value is used when the data value can be changed in the receiving node.</p></td></tr></tbody></table></div><p>The sender collects only necessary data for each transaction, creates xLog, and sends it to the Receiver of the other node.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Transaction</strong></p></td><td class="confluenceTd"><p><strong>Sender log</strong></p></td></tr><tr><td class="confluenceTd"><p>INSERT</p></td><td class="confluenceTd"><p>Table, Column Value</p></td></tr><tr><td class="confluenceTd"><p>UPDATE</p></td><td class="confluenceTd"><p>Table, PK, Before Value, After Value</p></td></tr><tr><td class="confluenceTd"><p>DELETE</p></td><td class="confluenceTd"><p>Table, PK</p></td></tr></tbody></table></div><p>Since the transaction that occurs locally is processed regardless of whether it is transmitted in replication (only the sender is checked), there is no interference due to replication, ensuring the processing performance. (This is called lazy mode replication.)</p><p>In this case, many would ask themselves if there is any data that the other party hasn't received? To answer this question, this will be explained in detail again from the receiver side.</p><p>The transmission method of the sender is the lazy mode by default, and can be set in such a way that it checks the transactions are reflected in the other node. This is called eager mode.</p><h2 id="AltibaseReplicationConfigurationGuide-Receiver">Receiver</h2><hr /><p>The receiver sends the received xLog to Receiver-Applier (hereinafter referred to as Applier). Since the received xLog is a transaction log recorded after processing through QueryProcessor in the other node, the Applier requests processing to SM without a separate validation process. (QueryProcessor refers to an internal module that performs validation and optimization for queries executed in the ALTIBASE.)</p><p>When reflecting in the receiving node, be sure to check whether the value of the received data and the value of the data existing in the own node are the same.</p><p>After reflecting, when the Receiver sends an ack to the other Sender, the Sender changes the location to which is should retransmit it. In order words, since multiple transaction XLogs can be contained in the communication buffer for replication, the Sender always records the location of the log it sends and the location of the transaction log to be retransmitted in preparation for failure between transmissions or failure of other nodes. This information is updated when receiving ack from the Receiver that some parts were reflected.</p><p>Therefore, since the Sender checks in a delayed form even if it does not immediately check whether the actual receiving node has reflected it, the case that the log to be sent by the Sender is not transmitted to the other party never occurs. This works the same even if a network failure occurs.</p><p>In other words, when it detects that a network failure has occurred, the Sender checks the network in a fixed periodic unit. When it detects that normal recovery has occurred, it connects to the Receiver of the other node and sends it again from the location where it needs to be transmitted.</p><h2 id="AltibaseReplicationConfigurationGuide-Problemsthatcanoccurinareplicationenvironment">Problems that can occur in a replication environment</h2><hr /><p>Since replication uses a network, the following problems can occur:</p><ol><li>Data conflict</li><li>Data transmission gap</li></ol><p>In the case of a transaction in which two nodes change data with the same PK to different values, the disk sharing method has no choice but to proceed with the change transaction one by one by the node requesting each processing. Therefore, if such transactions are frequent, the performance is bound to be slow.</p><p>On the other hand, unlike the disk sharing method, replication does not take into account changes to the data of other nodes when a local transaction occurs, so there is no interference with each other, but due to this, the data conflict that may occur.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"><strong>Order of occurrence</strong></p></td><td class="confluenceTd"><p align="center"><strong>Node A</strong></p></td><td class="confluenceTd"><p align="center"><strong>Node B</strong></p></td></tr><tr><td class="confluenceTd"><p align="center">Before occurrence</p></td><td class="confluenceTd"><p>Pk=1, c1=10</p></td><td class="confluenceTd"><p>Pk=1, c1=10</p></td></tr><tr><td class="confluenceTd"><p align="center">Update at the same time</p></td><td class="confluenceTd"><p>Update t1 set c1 = 15 where pk = 1</p></td><td class="confluenceTd"><p>Update t1 set c1 = 20 where pk = 1</p></td></tr><tr><td class="confluenceTd"><p align="center">After occurrence</p></td><td class="confluenceTd"><p>Pk=1, c1=15</p></td><td class="confluenceTd"><p>Pk=1, c1=20</p></td></tr><tr><td class="confluenceTd"><p align="center">Sender</p></td><td class="confluenceTd"><p>Send (t1, pk=1, c1=10 --&gt; 15)</p></td><td class="confluenceTd"><p>Send (t1, pk=1, c1=10 --&gt; 20)</p></td></tr></tbody></table></div><p>As in the example above, if the data has the same data but has the same PK before it is changed to different values, each node will proceed regardless of the transaction of the other node. At this time, if data is transmitted to each other while the change has already been completed, the previous values of the data are compared. In the case of node A, the current value of 15 and the received xLog is recorded as 10, so the transaction for the received xLog fails. This is called Update Conflict.</p><p>The types of Conflict are as follows.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"><strong>Type</strong></p></td><td class="confluenceTd"><p align="center"><strong>Description</strong></p></td></tr><tr><td class="confluenceTd"><p align="center">Dup Conflict</p></td><td class="confluenceTd"><p>When data having the same PK already exists in the receiving node while performing Insert, etc.</p></td></tr><tr><td class="confluenceTd"><p align="center">Update Conflict</p></td><td class="confluenceTd"><p>When the current value of the target column is not the same as the received value while performing Update</p></td></tr><tr><td class="confluenceTd"><p align="center">Not Found Conflict</p></td><td class="confluenceTd"><p>When data does not exist while performing Update or Delete on PK in the receiving node</p></td></tr></tbody></table></div><p>That is, when two or more nodes change data differently for the same PK, there may be cases in which data exists in an incorrect state at the same time.</p><p>To avoid this problem, it can be solved by triggering a transaction considering the PK of a separate range for each node. In other words, Active/Active should be configured considering the PK range, not the Full Active method.</p><p>Altibase provides a property called REPLICATION_UPDATE_REPLACE for this part so that even if the previous value is different fro the UPDATE transaction, the received value can be changed. However, this problem is not a perfect solution to the Update Conflict. This is because if all nodes that continuously perform the service have the same PK and continuously update data to different values, they will both eventually have different values again. This property is merely a provision by assuming that the data will be corrected at some point in the end.</p><p>Another problem of replication is that if the accumulating speed of the change transaction log of the sending node is faster than the xLog transmission speed to the other node, the data retrieved result of the sending node and the receiving node may be different at a specific time. In other words, it means a case in which transaction logs that could not be transmitted to the other node through the network are accumulated in the sending node, and this is called a replication gap.</p><p>These problems can make users hesitate to choose replication in terms of data consistency, even if high-performance data processing is possible. In the next section, we will take a look into how to properly avoid such data conflicts and delays to enable service with efficient replication configuration.</p><h1 id="AltibaseReplicationConfigurationGuide-EfficientReplicationConfiguration">Efficient Replication Configuration</h1><hr /><p>This section will describe the configuration method using the Off-line Replicator function and HA solution, which are complementary functions of replication provided by Altibase.</p><h2 id="AltibaseReplicationConfigurationGuide-Off-LineReplicator"><span style="color: rgb(0,0,0);">Off-Line Replicator</span></h2><hr /><p><span style="color: rgb(0,0,0);"> The delay of replication transmission is the problem of ensuring consistency due to data that could not be sent at the time of failure of the sending node. There is no change in the fact that the delay of transmission is reflected only with a difference in time when controlling is possible within the system configuration where the PK is separated, but the failure occurring the delayed sate can be critical for operating.</span></p><p><span style="color: rgb(0,0,0);">Altibase provides a function called Off-Line Replicator starting from ALTIBASE ver 5.3 to solve this problem. This function solves the data inconsistency by directly reflecting the data that was not transmitted by reading the transaction log file of the failed node by creating an Off-Line Replicator in the normal server when a failure occurs in the server that was actively serving it. (The operator can easily create it in the form of an SQL statement).</span></p><p><span style="color: rgb(0,0,0);">To use the Off-Line Replicator, it is possible to configure the disk sharing device so that all nodes can write each transaction log in the form of sharing the disk with the failed server, or connect to the failed server with FTP to bring and reflect the transaction log.</span></p><p><span style="color: rgb(0,0,0);">With this method, the consistency due to the non-transmission of data is eliminated and the service can be started in the normal node.</span></p><p><span style="color: rgb(0,0,0);"><img class="confluence-embedded-image" src="attachments/14647672/14778434.png" data-image-src="attachments/14647672/14778434.png"></span></p><p><span style="color: rgb(0,0,0);">The configuration is different depending on the system environment, but this is a method that reads the transaction log that failed to transmit the failed node directly from the normal node at the time of failure and reflects the normal node itself to prepare for the service switch.</span></p><h2 id="AltibaseReplicationConfigurationGuide-ServiceConfigurationusingtheHASolution"><span style="color: rgb(0,0,0);">Service Configuration using the HA Solution</span></h2><hr /><p><span style="color: rgb(0,0,0);">Configuration using the HA solution refers to one node performing a service and the other node is in a standby state. When the HA Solution checks the state of the node in service periodically and determines that there is a problem, the shared disk is switched to make the node in the standby state.</span></p><p><span style="color: rgb(0,0,0);">When applied to Altibase, there are the following limitations, but it has the advantage of avoiding the data inconsistency problem.</span></p><ol><li><span style="color: rgb(0,0,0);">Altibase of the standby node cannot be running. It must be in the completed state. (The engine itself cannot all run at the same time)</span></li><li><span style="color: rgb(0,0,0);">Since the running state has be to performed after the transmission, if the memory DB usage is large, it takes a long time in proportion to the size. In addition, if there is a large amount of operation at the time of failure, recovery time for this is required in the running stage. Therefore if service downtime is the priority, this should be considered.</span></li></ol><p><span style="color: rgb(0,0,0);"><img class="confluence-embedded-image" src="attachments/14647672/14778435.png" data-image-src="attachments/14647672/14778435.png"></span></p><p><span style="color: rgb(0,0,0);">The meaning of Active/Standy is the service standard, and Altibase of Standby means the completed state.</span></p><p><span style="color: rgb(0,0,0);">Generally, it is composed as follows.</span></p><p><span style="color: rgb(0,0,0);"> </span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"> </p></td><td class="confluenceTd"><strong>Configuration items</strong><p align="center"> </p></td></tr><tr><td class="confluenceTd"><p align="center">Shared disk</p></td><td class="confluenceTd">Transaction log file and data file<p> </p></td></tr><tr><td class="confluenceTd"><p align="center">Each node</p></td><td class="confluenceTd"><p>ALTIBASE engine, trace log file, license, property file</p></td></tr></tbody></table></div><p><span style="color: rgb(0,0,0);"> </span></p><p>If configured as above, when a situation in which the HA solution is switched over occurs, the standby node that can access the shared disk runs by using the transaction log and data file located on the shared disk, and the service can become available.</p><p><span style="color: rgb(0,0,0);">Since the configuration using this HA solution does not use replication with the network, there is no need to consider the data collision problem or the replication gap problem.</span></p><h2 id="AltibaseReplicationConfigurationGuide-DataDelayConsiderations"><span style="color: rgb(0,0,0);">Data Delay Considerations</span></h2><hr /><p>Generally. the replication of ALTIBASE is 1.2GHz or higher and CPU performance is about 10,000tps per second on average. That is, if the change transaction occurring within one node per second is within the above performance, it can be calculated that redundancy with the network can be processed without delay.</p><p><span style="color: rgb(0,0,0);">If the service itself handles only continuous changes, data delay cannot be avoided in the replication configuration with the network. However, it can be seen that it can be serviced if the amount of operations for changes is at the level that can be handled by replication and a service that takes into account the temporary delay of data.</span></p><p><span style="color: rgb(0,0,0);">Even if the data could not be sent at the time of the failure, it is possible to configure so that the service itself does not become a problem by performing a service after recovery with the Off-Line Replicator before service switch.</span></p><p><span style="color: rgb(0,0,0);">Such a configuration is based on prediction, and it is a case of considering transmission delay to some extent. If a service cannot consider transmission delay, a method of configuring the replication mode to Eager mode can be used.</span></p><p><span style="color: rgb(0,0,0);"> </span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"><strong>Replication operation method</strong></p></td><td class="confluenceTd"><p><strong>Description</strong></p></td></tr><tr><td class="confluenceTd"><p align="center">Lazy</p></td><td class="confluenceTd"><p>The sending node does not wait for the progress of the local transaction and the transmission of xLog.</p></td></tr><tr><td class="confluenceTd"><p align="center">Eager</p></td><td class="confluenceTd"><p>The sending node first reflects the local transaction and then sends the xLog to the receiving node, and waits until the result is returned after reflection</p></td></tr></tbody></table></div><p>The data transmission delay problem of replication described so far can occur in the lazy mode, and in order to avoid this problem, the Eager mode is provided. Since the Eager mode checks the reflection of the other node, there is no data delay. However, since it has to wait for the transaction of the other node to be reflected, the Eager mode causes a significant performance degradation compared to the Lazy mode. However, even in this part, the degree of performance degradation may not be significant depending on the proportion of the change operation among the entire transaction.</p><p>Therefore, the user can use Lazy/Eager mode separately according to the operation. If the task does not necessarily need to consider the data delay, use the Lazy mode that can enhance the performance, and if the task needs to consider the data delay, use the Eager mode. In addition, Since Eager/Lazy mode can be specified for each session, it can be applied separately by session.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"><strong>Operation</strong></p></td><td class="confluenceTd"><strong>Replication operation method</strong><p> </p></td></tr><tr><td class="confluenceTd"><p align="center">Account balance, deposit</p></td><td class="confluenceTd"><p>The session to perform this task is in Eager mode</p></td></tr><tr><td class="confluenceTd"><p align="center">Login time information</p></td><td class="confluenceTd"><p>The session to perform this task is in Lazy mode</p></td></tr></tbody></table></div><p>Unlike the Lazy mode, the local transaction also fails when conflict occurs in the Eager mode. Therefore, it should be well planned so that the data does not change due to transactions in the Lazy mode.</p><h2 id="AltibaseReplicationConfigurationGuide-Serviceconfigurationtopreventdataconflict"><span style="color: rgb(0,0,0);">Service configuration to prevent data conflict</span></h2><hr /><p>Data conflict occurs when trying to access data with the same PK at the same time in a replication environment. Therefore, it is recommended to configure the service so that the service program of the user does not access the same PK.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"><strong>Configuration</strong></p></td><td class="confluenceTd"><p><strong>Service configuration example 1</strong></p></td><td class="confluenceTd"><p><strong><strong>Service configuration example 2</strong></strong></p></td></tr><tr><td class="confluenceTd"><p align="center">Node A</p></td><td class="confluenceTd"><p>Change transaction + retrieve transaction</p></td><td class="confluenceTd">Transactions of Seoul and Gyeonggi areas<p> </p></td></tr><tr><td class="confluenceTd"><p align="center">Node B</p></td><td class="confluenceTd"><p>Retrieve transaction</p></td><td class="confluenceTd"><p>Transaction of Chungcheong, Jeolla, and Gyeongsang areas</p></td></tr></tbody></table></div><p>In the same configuration as for example 2 of the service configuration, there are many things to consider at the stage of user development, such as the distribution of transactions. This requires more consideration of how to classify the range and how to implement it.</p><p>Altibase provides the following functions for data conflict. It is important to find a proper configuration for each service configuration.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Method</strong></p></td><td colspan="3" class="confluenceTd"><p><strong>Description</strong></p></td></tr><tr><td class="confluenceTd"><p>REPLICATION_UPDATE_REPLACE=1</p></td><td colspan="3" class="confluenceTd">To update even if the received the before-value of xLog and the target data value of the receiving node do not match<p> </p></td></tr><tr><td rowspan="5" class="confluenceTd"><p>Master / Slave method</p></td><td colspan="3" class="confluenceTd"><p>Each node is designated as Master and Slave and operates as follows when data conflict occurs.</p></td></tr><tr><td class="confluenceTd"><p>Transaction</p></td><td class="confluenceTd"><p>Master</p></td><td class="confluenceTd"><p>Slave</p></td></tr><tr><td class="confluenceTd"><p>Insert</p></td><td class="confluenceTd"><p>Ignored</p></td><td class="confluenceTd"><p>Reflect after deleting existing data</p></td></tr><tr><td class="confluenceTd"><p>Update</p></td><td class="confluenceTd"><p><span>Ignored</span></p></td><td class="confluenceTd"><p>Reflect as it is</p></td></tr><tr><td class="confluenceTd"><p>Delete</p></td><td class="confluenceTd"><p><span>Ignored</span></p></td><td class="confluenceTd"><p><span>Ignored</span></p></td></tr><tr><td class="confluenceTd"><p>TimeStamp method</p></td><td colspan="3" class="confluenceTd"><p>To compare each TimeStamep when conflict occurs in the table configured in the replication and match it with the data that is created after.</p></td></tr></tbody></table></div><p>More detailed explanations can be found in the manual.</p><h2 id="AltibaseReplicationConfigurationGuide-Replicationconfigurationconsideringdataconsistency">Replication configuration considering data consistency</h2><hr /><p>As discussed above, replication requires the configuration of a service system in consideration of the problem of data delay and conflict. If the following configuration is made using the function provided by Altibase, the data inconsistency and delay can be completely solved.</p><ol><li>Configure Active/Standby type</li><li>Failure recovery with the Off-Line Replicator</li></ol><p>All services are performed by one side, and when a failure occurs, it refers to a method of starting service by performing a reflection on data that has not been reflected with the Offline Replicator and switching the service.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p align="center"><strong>Situation</strong></p></td><td class="confluenceTd"><p align="center"><strong>Node A</strong></p></td><td class="confluenceTd"><p align="center"><strong>Node B</strong></p></td></tr><tr><td class="confluenceTd"><p align="center">Normal Service</p></td><td class="confluenceTd"><p>Process all services</p></td><td class="confluenceTd">Receive only replication logs, standby status<p> </p></td></tr><tr><td class="confluenceTd"><p align="center">Failure occurs</p></td><td class="confluenceTd"><p>Perform failure recovery</p></td><td class="confluenceTd"><p>After reflecting all transaction logs of Node A that Node B has not received with the Off-Line Replicator, service is performed at Node B</p></td></tr><tr><td class="confluenceTd"><p align="center">Node A recovery</p></td><td class="confluenceTd"><p>Match data by receiving all replication logs from Node B after failure</p></td><td class="confluenceTd"><p>Automatically detect recovery of Node A and transmit all transaction logs after failure from replication</p></td></tr></tbody></table></div><p>When using the HA solution in the above configuration, it is possible to automate all processes of switching services when a failure occurs with the HA solution without user intervention. As the Off-Line Replicator operates in the form of SQL statement as described above, it is possible to easily automate it by including it in the operation procedure of the switching situation if it registered in the script form in the HA solution.</p><h2 id="AltibaseReplicationConfigurationGuide-DesignofN-WayReplication">Design of N-Way Replication</h2><hr /><p>The replication of Altibase supports N-way replication, and up to a total of 1:32 nodes can be connected. When more than three nodes are configured as replication, the replication object should be created as follows, and the network expansion card should be considered in advance.</p><p><img class="confluence-embedded-image" width="500" src="attachments/14647672/14778436.png" data-image-src="attachments/14647672/14778436.png"></p><p>Sender/Receiver for each target connection must exist in every node, and for this purpose, the target node to which it wants to send data and each replication object must be created. In the above figure, a replication object between (A-B, A-C) should be created in the A node. Node B can synchronize data between (A-B-C) normally only when the replication object between (B-A, B-C) created.</p><h2 id="AltibaseReplicationConfigurationGuide-ImportanceofReplicationDesign">Importance of Replication Design</h2><hr /><p>The important thing can be said to be the design part of whether to use each function in a good combination suitable for the operation purpose. At the design stage, the following two options should be fully considered.</p><ol><li>Which method to choose between a lazy and eager mode for the replication? Or, if both are used together, what kind of operation will be serviced in different ways?</li><li>What is the right solution for data conflict and delay?</li></ol><h1 id="AltibaseReplicationConfigurationGuide-AdditionalConsiderationsforReplicationConfiguration">Additional Considerations for Replication Configuration</h1><hr /><p>This section describes considerations for replication configuration.</p><h2 id="AltibaseReplicationConfigurationGuide-ConsiderationsforDiskCapacity">Considerations for Disk Capacity</h2><hr /><p>If a problem occurs in the replication connection in any form, the Sender cannot send transaction logs occurring locally to the other node. In this case, even if a checkpoint occurs, the transaction log files cannot be deleted to maintain the log files to be replicated.</p><p>Therefore, there is a possibility that a failure of insufficient disk space may occur due to the accumulation of secondary transaction log files due to a failure of the primary transmission delay. To avoid this problem, if a transaction log file exceeds the specified value by using the property called REPLICATION_MAX_LOGFILE, all replication transmission histories are abandoned and the transaction log file can be deleted at the checkpoint.</p><p>However, in this case, it is not recommended unless there is a special occasion because the user needs to match the consistency of the DB between nodes after failure recovery. Rather it is recommended to calculate the disk capacity in advance so that it does not become a problem even if it accumulates as much as the expected time required to overcome a failure in consideration of the daily occurrence of the transaction log.</p><h2 id="AltibaseReplicationConfigurationGuide-CautionforBulkChange">Caution for Bulk Change</h2><hr /><p>What is sent in replication is based on the transaction log, not based on SQL. Therefore, when the bulk change is performed, the transaction log must be transmitted to the other node as much as the number of changed data. For this reason, in the case of a busy system that handles very frequent services, the reflection is delayed. Therefore, the following two methods are recommended to perform the bulk change.</p><ol><li>The process by dividing into small account of change operation using the limit clause</li><li>alter session set replication = false; the same change is performed on all nodes by using the option.</li></ol><h2 id="AltibaseReplicationConfigurationGuide-SenderStatusMonitoring"><span style="color: rgb(0,0,0);">Sender Status Monitoring</span></h2><hr /><p>If a Sender exists in the stopped state after being started at least once, the log to be sent is continuously maintained. In this case, it should be noted that if the user doe not monitor separately, a disk pool failure may occur due to an increase in the transaction logs.</p><h2 id="AltibaseReplicationConfigurationGuide-ReplicationDedicatedLine">Replication Dedicated Line</h2><hr /><p>It is recommended to use a dedicated line separately from the service network for replication. In particular, it is recommended to use a network with a bandwidth of 1G or higher. In addition, it is also recommended to secure stability by having two or more dedicated LAN cards for replication in case of network failure.</p><h2 id="AltibaseReplicationConfigurationGuide-ParallelApplierOption">Parallel Applier Option</h2><hr /><p>Parallel Applier is an option that improves replication performance by creating multiple appliers that are reflected in the storage manager.</p><p>The replication performance is improved by distributing the xLog received from the Sender in a transaction unit so that the Receiver can process the xLog received from the Sender in parallel, and executing XML in parallel. Therefore, this option is suitable for replication consisting of long transactions. When there are many replication transactions composed of short transactions, performance may be degraded because they undergo frequent commit sync commits. So, when there are many replication transactions composed of long transactions, performance can be improved because the sync commit process is rare.</p><h2 id="AltibaseReplicationConfigurationGuide-SequenceReplication">Sequence Replication</h2><hr /><p>The sequence replication is a function that allows a remote server and local server to use the same sequence even when a Fail-over occurs. Thus, the same sequence and the same program source can be used in the application.</p><p>The sequence replication requires that the cache start value is duplicated so that sequence values do not overlap in two servers. The cache-sized sequence is stored in memory and used, and when all stored sequences are used, the cache-sized sequence is stored in memory.</p><p>The Altibase replication supports only tables, so a table for sequence replication is internally created.</p><h2 id="AltibaseReplicationConfigurationGuide-ConstraintstoConsiderforReplicationConfiguration"><span style="color: rgb(0,0,0);">Constraints to Consider for Replication Configuration</span></h2><hr /><ul><li>Tables configured for replication must have PK.</li><li>Tables configured for replication cannot update PK. (From the DBMS side, it can be said that the implementation of the operation that tries to update the PK itself is the wrong method.)</li><li>Tables in a node configured for replication must have the same column information, PK, and NOT NULL information.</li><li>Since there is a possibility that data inconsistency may occur due to delay of replication, it is recommended not to use trigger and foreign-key at the source. However, this can be allowed depending on the configuration environment or operation purpose.</li><li>When executing DDL operation on a table configured for replication, the table must be temporarily removed from the target replication list in the replication before executing it. (Some DDLs (such as add column) can be executed without removing the list of tables in replication during operation. Refer to the manual for details)</li><li>Since the reflecting speed of the memory DB and the reflecting speed of the disk DB are different, it is recommended to take the replication object separately for memory and disk when the order of reflecting memory and disk is not important for the operation.</li><li>Refer to the process of transferring service to another normal node when a failure occurs between nodes configured for service. Fail-over allows only minimal service downtime.</li></ul><h1 id="AltibaseReplicationConfigurationGuide-Summary">Summary</h1><hr /><p>We have described the overview, problems, and solutions of Altibase replication.</p><p>Replication using a network clearly has a data consistency problem due to transmission delay in case of data conflict or failure. However, it is possible to avoid the problem of data conflict by classifying the range of the change transaction by node properly with operation analysis as in real cases. The problem of data consistency occurring when a failure occurs can be solved with the Off-Line Replicator.</p><p>Therefore, the following three processes should be sufficiently considered:</p><ol><li><p>It is necessary to first identify the operation requirements to prevent data conflict.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong> </strong></p></td><td class="confluenceTd"><p align="center"><strong>When configuring Active/Active</strong></p></td><td class="confluenceTd"><p align="center"><strong>When configuring Active/Standby</strong></p></td></tr><tr><td class="confluenceTd"><p>Task implementation requirements</p></td><td class="confluenceTd"><p>·Separate configuration for each task</p><p>·Separate configuration of the scope of change</p></td><td class="confluenceTd"><p>· Only one node performs the change transaction</p><p>· Retrieve transaction is executed on one or all nodes</p></td></tr><tr><td class="confluenceTd"><p align="center">Purpose</p></td><td colspan="2" class="confluenceTd"><p>Aim to configure redundancy so that data conflict does not occur at the source by preventing access to the same PK.</p></td></tr></tbody></table></div><p>● Active/Standby classification is based on service (This refers to that all ALTIBASE engines are running)</p></li><li>In the event of a failure, the data could not be transmitted. As described above, this part should be solved with the Off-Line Replicator provided in ALTIBASE version 5.3 or later, or the system configuration should be made.</li><li>As in the &quot;Constraints to Consider for Replication Configuration&quot; mentioned in the document, there are constraints that must be considered for replication configuration, but it should be noted that the replication configuration itself may not be possible if this is recognized at the design stage.</li></ol><div><span style="color: rgb(0,0,0);font-size: 20.0px;"><br /></span></div>
                    </div>

                                        <div class="pageSection group">
                        <div class="pageSectionHeader">
                            <h2 id="attachments" class="pageSectionTitle">Attachments:</h2>
                        </div>

                        <div class="greybox" align="left">
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/14647672/14778432.png">disk-share_eng.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/14647672/14778433.png">rep_confi_eng.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/14647672/14778434.png">offline_eng.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/14647672/14778435.png">disk_share2.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/14647672/14778436.png">nway_eng.png</a> (image/png)
                                <br/>
                                                    </div>
                    </div>
                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 23, 2021 09:49</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
